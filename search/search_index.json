{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GitHub Actions Kotlin DSL \ud83e\uddea Work in progress - \"moving fast\" phase Please expect breaking API changes (they're documented in release notes) and missing features. \ud83d\udca1 Idea YAMLs and JSONs surround us more and more frequently. While their syntax is simple and they allow defining hierarchical data easily, the tendency is also to overuse them for more complicated scenarios where a power of a regular programming language would be beneficial. This library aims at filling this gap, utilizing Kotlin as a modern general-purpose language with good internal DSL support. \u2728 Benefits no more confusion about YAML's indent level - Kotlin's syntax doesn't rely on it thanks to Kotlin being a compiled language, adds a compilation phase where a number of errors can be caught and prevented from getting into your workflows' runtime phase superb IDE support: author your workflows in any IDE that supports Kotlin, with auto-completion remove duplication: ability to extract common parts to constants or functions programmatically generate your workflow's arbitrarily complex logic, you can even call an external service and generate your workflow based on the response. Whatever Kotlin and the JVM allows you to do \ud83c\udfa5 Video presentation Here's a detailed presentation of the library by Piotr Krzemi\u0144ski, along with simple demos:","title":"Introduction"},{"location":"#github-actions-kotlin-dsl","text":"","title":"GitHub Actions Kotlin DSL"},{"location":"#work-in-progress-moving-fast-phase","text":"Please expect breaking API changes (they're documented in release notes) and missing features.","title":"\ud83e\uddea Work in progress - \"moving fast\" phase"},{"location":"#idea","text":"YAMLs and JSONs surround us more and more frequently. While their syntax is simple and they allow defining hierarchical data easily, the tendency is also to overuse them for more complicated scenarios where a power of a regular programming language would be beneficial. This library aims at filling this gap, utilizing Kotlin as a modern general-purpose language with good internal DSL support.","title":"\ud83d\udca1 Idea"},{"location":"#benefits","text":"no more confusion about YAML's indent level - Kotlin's syntax doesn't rely on it thanks to Kotlin being a compiled language, adds a compilation phase where a number of errors can be caught and prevented from getting into your workflows' runtime phase superb IDE support: author your workflows in any IDE that supports Kotlin, with auto-completion remove duplication: ability to extract common parts to constants or functions programmatically generate your workflow's arbitrarily complex logic, you can even call an external service and generate your workflow based on the response. Whatever Kotlin and the JVM allows you to do","title":"\u2728 Benefits"},{"location":"#video-presentation","text":"Here's a detailed presentation of the library by Piotr Krzemi\u0144ski, along with simple demos:","title":"\ud83c\udfa5 Video presentation"},{"location":"projects-using-this-library/","text":"Projects using this library It's also a great source of examples how to use the library. github-actions-kotlin-dsl (this library - we dogfood , of course) kotlin-python twitch-announcement-discord-bot Petals feel free to add your project here!","title":"Projects using this library"},{"location":"projects-using-this-library/#projects-using-this-library","text":"It's also a great source of examples how to use the library. github-actions-kotlin-dsl (this library - we dogfood , of course) kotlin-python twitch-announcement-discord-bot Petals feel free to add your project here!","title":"Projects using this library"},{"location":"supported-actions/","text":"This is a complete list of actions for which the library provides typed wrappers, grouped by owners. If your action is not on the list, see Using actions section. Click on a version to see the wrapper's code. Wrappers 10up action-wordpress-plugin-deploy - v2.0.0: ActionWordpressPluginDeployV2 8398a7 action-slack - v3: ActionSlackV3 actions-rs audit-check - v1: AuditCheckV1 cargo - v1: CargoV1 clippy-check - v1: ClippyCheckV1 toolchain - v1: ToolchainV1 actions cache - v2: CacheV2 , v3: CacheV3 checkout - v2: CheckoutV2 , v3: CheckoutV3 create-release - v1: CreateReleaseV1 download-artifact - v2: DownloadArtifactV2 , v3: DownloadArtifactV3 first-interaction - v1: FirstInteractionV1 github-script - v6: GithubScriptV6 labeler - v4: LabelerV4 setup-dotnet - v2: SetupDotnetV2 setup-go - v3: SetupGoV3 setup-java - v2: SetupJavaV2 , v3: SetupJavaV3 setup-node - v2: SetupNodeV2 , v3: SetupNodeV3 setup-python - v2: SetupPythonV2 , v3: SetupPythonV3 , v4: SetupPythonV4 stale - v5: StaleV5 upload-artifact - v2: UploadArtifactV2 , v3: UploadArtifactV3 ad-m github-push-action - v0.6.0: GithubPushActionV0 AkhileshNS heroku-deploy - v3.12.12: HerokuDeployV3 anmol098 waka-readme-stats - v4: WakaReadmeStatsV4 anothrNick github-tag-action - v1.38.0: GithubTagActionV1 appleboy scp-action - v0.1.3: ScpActionV0 ssh-action - v0.1.4: SshActionV0 telegram-action - v0.1.1: TelegramActionV0 aws-actions amazon-ecr-login - v1: AmazonEcrLoginV1 amazon-ecs-deploy-task-definition - v1: AmazonEcsDeployTaskDefinitionV1 amazon-ecs-render-task-definition - v1: AmazonEcsRenderTaskDefinitionV1 configure-aws-credentials - v1: ConfigureAwsCredentialsV1 axel-op googlejavaformat-action - v3: GooglejavaformatActionV3 Azure docker-login - v1: DockerLoginV1 login - v1: LoginV1 webapps-deploy - v2: WebappsDeployV2 bahmutov npm-install - v1: NpmInstallV1 Borales actions-yarn - v2.3.0: ActionsYarnV2 , v3: ActionsYarnV3 cachix install-nix-action - v17: InstallNixActionV17 calibreapp image-actions - v1.1.0: ImageActionsV1 codecov codecov-action - v3: CodecovActionV3 coverallsapp github-action - 1.1.3: GithubActionV1 docker build-push-action - v2: BuildPushActionV2 , v3: BuildPushActionV3 login-action - v1: LoginActionV1 , v2: LoginActionV2 setup-buildx-action - v1: SetupBuildxActionV1 , v2: SetupBuildxActionV2 elgohr Publish-Docker-Github-Action - v4: PublishDockerGithubActionV4 EndBug add-and-commit - v8: AddAndCommitV8 , v9: AddAndCommitV9 gautamkrishnar blog-post-workflow - v1: BlogPostWorkflowV1 google-github-actions auth - v0: AuthV0 setup-gcloud - v0: SetupGcloudV0 GoogleCloudPlatform github-actions - v0: GithubActionsV0 gradle-update update-gradle-wrapper-action - v1: UpdateGradleWrapperActionV1 gradle gradle-build-action - v2: GradleBuildActionV2 wrapper-validation-action - v1: WrapperValidationActionV1 JamesIves github-pages-deploy-action - v4: GithubPagesDeployActionV4 JasonEtco create-an-issue - v2: CreateAnIssueV2 julia-actions setup-julia - v1: SetupJuliaV1 krzema12 github-actions-typing - v0: GithubActionsTypingV0 madhead check-gradle-version - v1: CheckGradleVersionV1 read-java-properties - latest: ReadJavaProperties semver-utils - v2: SemverUtilsV2 microsoft setup-msbuild - v1: SetupMsbuildV1 nobrayner discord-webhook - v1: DiscordWebhookV1 peaceiris actions-gh-pages - v3: ActionsGhPagesV3 actions-hugo - v2: ActionsHugoV2 peter-evans create-issue-from-file - v4: CreateIssueFromFileV4 create-pull-request - v4: CreatePullRequestV4 peterjgrainger action-create-branch - v2.2.0: ActionCreateBranchV2 repo-sync pull-request - v2: PullRequestV2 ruby setup-ruby - v1: SetupRubyV1 SamKirkland FTP-Deploy-Action - v4.3.0: FTPDeployActionV4 softprops action-gh-release - v1: ActionGhReleaseV1 stefanzweifel git-auto-commit-action - v4: GitAutoCommitActionV4 subosito flutter-action - v2: FlutterActionV2 supercharge mongodb-github-action - 1.7.0: MongodbGithubActionV1 Vampire setup-wsl - v1: SetupWslV1 w9jds firebase-action - v2.2.2: FirebaseActionV2 Statistics Number of wrappers available: counting by actions: 76 counting each version separately: 89","title":"Supported actions"},{"location":"supported-actions/#wrappers","text":"10up action-wordpress-plugin-deploy - v2.0.0: ActionWordpressPluginDeployV2 8398a7 action-slack - v3: ActionSlackV3 actions-rs audit-check - v1: AuditCheckV1 cargo - v1: CargoV1 clippy-check - v1: ClippyCheckV1 toolchain - v1: ToolchainV1 actions cache - v2: CacheV2 , v3: CacheV3 checkout - v2: CheckoutV2 , v3: CheckoutV3 create-release - v1: CreateReleaseV1 download-artifact - v2: DownloadArtifactV2 , v3: DownloadArtifactV3 first-interaction - v1: FirstInteractionV1 github-script - v6: GithubScriptV6 labeler - v4: LabelerV4 setup-dotnet - v2: SetupDotnetV2 setup-go - v3: SetupGoV3 setup-java - v2: SetupJavaV2 , v3: SetupJavaV3 setup-node - v2: SetupNodeV2 , v3: SetupNodeV3 setup-python - v2: SetupPythonV2 , v3: SetupPythonV3 , v4: SetupPythonV4 stale - v5: StaleV5 upload-artifact - v2: UploadArtifactV2 , v3: UploadArtifactV3 ad-m github-push-action - v0.6.0: GithubPushActionV0 AkhileshNS heroku-deploy - v3.12.12: HerokuDeployV3 anmol098 waka-readme-stats - v4: WakaReadmeStatsV4 anothrNick github-tag-action - v1.38.0: GithubTagActionV1 appleboy scp-action - v0.1.3: ScpActionV0 ssh-action - v0.1.4: SshActionV0 telegram-action - v0.1.1: TelegramActionV0 aws-actions amazon-ecr-login - v1: AmazonEcrLoginV1 amazon-ecs-deploy-task-definition - v1: AmazonEcsDeployTaskDefinitionV1 amazon-ecs-render-task-definition - v1: AmazonEcsRenderTaskDefinitionV1 configure-aws-credentials - v1: ConfigureAwsCredentialsV1 axel-op googlejavaformat-action - v3: GooglejavaformatActionV3 Azure docker-login - v1: DockerLoginV1 login - v1: LoginV1 webapps-deploy - v2: WebappsDeployV2 bahmutov npm-install - v1: NpmInstallV1 Borales actions-yarn - v2.3.0: ActionsYarnV2 , v3: ActionsYarnV3 cachix install-nix-action - v17: InstallNixActionV17 calibreapp image-actions - v1.1.0: ImageActionsV1 codecov codecov-action - v3: CodecovActionV3 coverallsapp github-action - 1.1.3: GithubActionV1 docker build-push-action - v2: BuildPushActionV2 , v3: BuildPushActionV3 login-action - v1: LoginActionV1 , v2: LoginActionV2 setup-buildx-action - v1: SetupBuildxActionV1 , v2: SetupBuildxActionV2 elgohr Publish-Docker-Github-Action - v4: PublishDockerGithubActionV4 EndBug add-and-commit - v8: AddAndCommitV8 , v9: AddAndCommitV9 gautamkrishnar blog-post-workflow - v1: BlogPostWorkflowV1 google-github-actions auth - v0: AuthV0 setup-gcloud - v0: SetupGcloudV0 GoogleCloudPlatform github-actions - v0: GithubActionsV0 gradle-update update-gradle-wrapper-action - v1: UpdateGradleWrapperActionV1 gradle gradle-build-action - v2: GradleBuildActionV2 wrapper-validation-action - v1: WrapperValidationActionV1 JamesIves github-pages-deploy-action - v4: GithubPagesDeployActionV4 JasonEtco create-an-issue - v2: CreateAnIssueV2 julia-actions setup-julia - v1: SetupJuliaV1 krzema12 github-actions-typing - v0: GithubActionsTypingV0 madhead check-gradle-version - v1: CheckGradleVersionV1 read-java-properties - latest: ReadJavaProperties semver-utils - v2: SemverUtilsV2 microsoft setup-msbuild - v1: SetupMsbuildV1 nobrayner discord-webhook - v1: DiscordWebhookV1 peaceiris actions-gh-pages - v3: ActionsGhPagesV3 actions-hugo - v2: ActionsHugoV2 peter-evans create-issue-from-file - v4: CreateIssueFromFileV4 create-pull-request - v4: CreatePullRequestV4 peterjgrainger action-create-branch - v2.2.0: ActionCreateBranchV2 repo-sync pull-request - v2: PullRequestV2 ruby setup-ruby - v1: SetupRubyV1 SamKirkland FTP-Deploy-Action - v4.3.0: FTPDeployActionV4 softprops action-gh-release - v1: ActionGhReleaseV1 stefanzweifel git-auto-commit-action - v4: GitAutoCommitActionV4 subosito flutter-action - v2: FlutterActionV2 supercharge mongodb-github-action - 1.7.0: MongodbGithubActionV1 Vampire setup-wsl - v1: SetupWslV1 w9jds firebase-action - v2.2.2: FirebaseActionV2","title":"Wrappers"},{"location":"supported-actions/#statistics","text":"Number of wrappers available: counting by actions: 76 counting each version separately: 89","title":"Statistics"},{"location":"user-guide/compensating-librarys-missing-features/","text":"Compensating library's missing features You may find yourself willing to use GitHub Actions' feature that is not yet reflected in this library, neither in the core workflows/jobs/steps API, nor in the action wrappers. We've thought about it. The library provides several points of extension so that you can keep using it, and in the meantime report the missing feature to us so that we can add it to one of the next releases. See the below sections to find your specific case. The general approach is that whatever is overridden/customized using the below approaches, takes the precedence over built-in arguments. Workflows, jobs and steps They have an extra argument - _customArguments - which is a map from String to various subtypes of CustomValue . For example: workflow ( //... _customArguments = mapOf ( \"dry-run\" to BooleanCustomValue ( true ), \"some-string-value\" to StringCustomValue ( \"foobar\" ), \"written-by\" to ListCustomValue ( \"Alice\" , \"Bob\" ), \"concurrency\" to ObjectCustomValue ( mapOf ( \"group\" to expr ( \"github.ref\" ), \"cancel-in-progress\" to \"true\" , ) ) ), ) Action's inputs Each action wrapper has an extra constructor parameter - _customInputs - which is a map from String to String : UploadArtifactV2 ( //... _customInputs = mapOf ( \"path\" to \"override-path-value\" , \"answer\" to \"42\" , ) ) You can use it to set inputs that the wrapper doesn't know about, or to set any custom value if the wrapper's typing is incorrect or faulty. Action's version Each action wrapper has an extra constructor parameter - _customVersion - which is a string overriding action's version: UploadArtifactV2 ( //... _customVersion = \"v3\" ) It's useful e.g. when the wrapper doesn't keep up with action's versions and the API is fairly compatible, or if you want to use a specific minor version. I still cannot customize what I need Well, it means we missed something - sorry for that! Please report it via GitHub issues.","title":"Compensating library's missing features"},{"location":"user-guide/compensating-librarys-missing-features/#compensating-librarys-missing-features","text":"You may find yourself willing to use GitHub Actions' feature that is not yet reflected in this library, neither in the core workflows/jobs/steps API, nor in the action wrappers. We've thought about it. The library provides several points of extension so that you can keep using it, and in the meantime report the missing feature to us so that we can add it to one of the next releases. See the below sections to find your specific case. The general approach is that whatever is overridden/customized using the below approaches, takes the precedence over built-in arguments.","title":"Compensating library's missing features"},{"location":"user-guide/compensating-librarys-missing-features/#workflows-jobs-and-steps","text":"They have an extra argument - _customArguments - which is a map from String to various subtypes of CustomValue . For example: workflow ( //... _customArguments = mapOf ( \"dry-run\" to BooleanCustomValue ( true ), \"some-string-value\" to StringCustomValue ( \"foobar\" ), \"written-by\" to ListCustomValue ( \"Alice\" , \"Bob\" ), \"concurrency\" to ObjectCustomValue ( mapOf ( \"group\" to expr ( \"github.ref\" ), \"cancel-in-progress\" to \"true\" , ) ) ), )","title":"Workflows, jobs and steps"},{"location":"user-guide/compensating-librarys-missing-features/#actions-inputs","text":"Each action wrapper has an extra constructor parameter - _customInputs - which is a map from String to String : UploadArtifactV2 ( //... _customInputs = mapOf ( \"path\" to \"override-path-value\" , \"answer\" to \"42\" , ) ) You can use it to set inputs that the wrapper doesn't know about, or to set any custom value if the wrapper's typing is incorrect or faulty.","title":"Action's inputs"},{"location":"user-guide/compensating-librarys-missing-features/#actions-version","text":"Each action wrapper has an extra constructor parameter - _customVersion - which is a string overriding action's version: UploadArtifactV2 ( //... _customVersion = \"v3\" ) It's useful e.g. when the wrapper doesn't keep up with action's versions and the API is fairly compatible, or if you want to use a specific minor version.","title":"Action's version"},{"location":"user-guide/compensating-librarys-missing-features/#i-still-cannot-customize-what-i-need","text":"Well, it means we missed something - sorry for that! Please report it via GitHub issues.","title":"I still cannot customize what I need"},{"location":"user-guide/getting_started/","text":"Getting started Automatic migration of existing workflows This chapter describes how to start from scratch with something simple, so that you get a gist of how this library works. If you prefer to try automatic conversion of your workflows, head over to Script generator chapter. As an exercise, we'll add a job that prints out Hello world! . Feel free to replace the actual workflow's logic and all names with your own. Install Kotlin as a stand-alone binary, e.g. from Snap Store when on Linux: sudo snap install kotlin --classic Make sure this is the newest version available. Kotlin scripting still has some rough edges, and improvements are introduced with each new Kotlin release. Also make sure that you use Java 11+. Create a new executable file in your repository: touch .github/workflows/hello_world_workflow.main.kts chmod +x .github/workflows/hello_world_workflow.main.kts This location is not a hard requirement, it's just recommended for consistency with enforced location of actual GitHub Actions workflows. Put this content into the previously created file and save it: #!/usr/bin/env kotlin @file : DependsOn ( \"it.krzeminski:github-actions-kotlin-dsl:0.22.0\" ) import it.krzeminski.githubactions.actions.actions.CheckoutV2 import it.krzeminski.githubactions.domain.RunnerType.UbuntuLatest import it.krzeminski.githubactions.domain.triggers.Push import it.krzeminski.githubactions.dsl.workflow import it.krzeminski.githubactions.yaml.toYaml import java.nio.file.Paths val workflow = workflow ( name = \"Test workflow\" , on = listOf ( Push ()), sourceFile = __FILE__ . toPath (), ) { job ( id = \"test_job\" , runsOn = UbuntuLatest ) { uses ( name = \"Check out\" , action = CheckoutV2 ()) run ( name = \"Print greeting\" , command = \"echo 'Hello world!'\" ) } } println ( workflow . toYaml ()) Explanation: first, we create a workflow with the DSL provided by this library. The reason it needs source file path is to be able to generate consistency checks, to ensure that both source and target files are in sync. You'll see it in a moment in the generated file. What's written to the workflow variable is an object of type it.krzeminski.githubactions.domain.Workflow , it's not a YAML yet. However, a call to toYaml() extension function does the final piece of job. Alternatively, apart from toYaml() which returns a string, there's also writeToFile() which puts the string straight into the file under path inferred by the library or name overridden with targetFileName workflow argument. It may come in handy when having a single script generating multiple workflows. Generate the YAML by calling the above script and redirecting its output to the desired YAML file path: .github/workflows/hello_world_workflow.main.kts > .github/workflows/hello_world_workflow.yaml It can be also executed straight from IntelliJ, by clicking the green \u25b6\ufe0fbutton next to the shebang. Notice that there's an extra job generated by the library that regenerates the YAML in job's runtime and ensures that it's equal to the YAML committed to the repository. Commit both files, push the changes to GitHub and make sure the workflow is green when ran on GitHub Actions.","title":"Getting started"},{"location":"user-guide/getting_started/#getting-started","text":"Automatic migration of existing workflows This chapter describes how to start from scratch with something simple, so that you get a gist of how this library works. If you prefer to try automatic conversion of your workflows, head over to Script generator chapter. As an exercise, we'll add a job that prints out Hello world! . Feel free to replace the actual workflow's logic and all names with your own. Install Kotlin as a stand-alone binary, e.g. from Snap Store when on Linux: sudo snap install kotlin --classic Make sure this is the newest version available. Kotlin scripting still has some rough edges, and improvements are introduced with each new Kotlin release. Also make sure that you use Java 11+. Create a new executable file in your repository: touch .github/workflows/hello_world_workflow.main.kts chmod +x .github/workflows/hello_world_workflow.main.kts This location is not a hard requirement, it's just recommended for consistency with enforced location of actual GitHub Actions workflows. Put this content into the previously created file and save it: #!/usr/bin/env kotlin @file : DependsOn ( \"it.krzeminski:github-actions-kotlin-dsl:0.22.0\" ) import it.krzeminski.githubactions.actions.actions.CheckoutV2 import it.krzeminski.githubactions.domain.RunnerType.UbuntuLatest import it.krzeminski.githubactions.domain.triggers.Push import it.krzeminski.githubactions.dsl.workflow import it.krzeminski.githubactions.yaml.toYaml import java.nio.file.Paths val workflow = workflow ( name = \"Test workflow\" , on = listOf ( Push ()), sourceFile = __FILE__ . toPath (), ) { job ( id = \"test_job\" , runsOn = UbuntuLatest ) { uses ( name = \"Check out\" , action = CheckoutV2 ()) run ( name = \"Print greeting\" , command = \"echo 'Hello world!'\" ) } } println ( workflow . toYaml ()) Explanation: first, we create a workflow with the DSL provided by this library. The reason it needs source file path is to be able to generate consistency checks, to ensure that both source and target files are in sync. You'll see it in a moment in the generated file. What's written to the workflow variable is an object of type it.krzeminski.githubactions.domain.Workflow , it's not a YAML yet. However, a call to toYaml() extension function does the final piece of job. Alternatively, apart from toYaml() which returns a string, there's also writeToFile() which puts the string straight into the file under path inferred by the library or name overridden with targetFileName workflow argument. It may come in handy when having a single script generating multiple workflows. Generate the YAML by calling the above script and redirecting its output to the desired YAML file path: .github/workflows/hello_world_workflow.main.kts > .github/workflows/hello_world_workflow.yaml It can be also executed straight from IntelliJ, by clicking the green \u25b6\ufe0fbutton next to the shebang. Notice that there's an extra job generated by the library that regenerates the YAML in job's runtime and ensures that it's equal to the YAML committed to the repository. Commit both files, push the changes to GitHub and make sure the workflow is green when ran on GitHub Actions.","title":"Getting started"},{"location":"user-guide/nightly-builds/","text":"Nightly builds Sometimes you may want to test a change that has been already merged to main or other branch, but not yet officially released. In this case, you can use JitPack to request building the desired version of the library on demand: https://jitpack.io/#krzema12/github-actions-kotlin-dsl To use the newest, bleeding-edge version from main branch, replace your scripts' preamble with: @file : Repository ( \"https://jitpack.io\" ) @file : DependsOn ( \"com.github.krzema12:github-actions-kotlin-dsl:main-SNAPSHOT\" ) Remember that the version main-SNAPSHOT may return a different build of the library each time because main branch gets new commits over time. If it's important to you to have more stability, consider e.g. pinning your dependency to a specific commit. See the above link on JitPack to learn multiple ways how JitPack can refer to the library's versions. JitPack lazily builds the library on demand, so it may happen that you will wait for the dependency resolution until the build is done. It usually takes up to several minutes, and you can preview the progress on JitPack.","title":"Nightly builds"},{"location":"user-guide/nightly-builds/#nightly-builds","text":"Sometimes you may want to test a change that has been already merged to main or other branch, but not yet officially released. In this case, you can use JitPack to request building the desired version of the library on demand: https://jitpack.io/#krzema12/github-actions-kotlin-dsl To use the newest, bleeding-edge version from main branch, replace your scripts' preamble with: @file : Repository ( \"https://jitpack.io\" ) @file : DependsOn ( \"com.github.krzema12:github-actions-kotlin-dsl:main-SNAPSHOT\" ) Remember that the version main-SNAPSHOT may return a different build of the library each time because main branch gets new commits over time. If it's important to you to have more stability, consider e.g. pinning your dependency to a specific commit. See the above link on JitPack to learn multiple ways how JitPack can refer to the library's versions. JitPack lazily builds the library on demand, so it may happen that you will wait for the dependency resolution until the build is done. It usually takes up to several minutes, and you can preview the progress on JitPack.","title":"Nightly builds"},{"location":"user-guide/script-generator/","text":"If you have an existing working GitHub YAML workflow, the script generator can convert it to a Kotlin script! It may not produce the most readable or by any means final code (as with every code generator), but it's a good starting point when you want to save time on migrating your workflows to YAML. Generate Kotlin Script from existing YAML To use it, clone the repository locally, in a version corresponding to the latest released version of the library: git clone -b v0.22.0 https://github.com/krzema12/github-actions-kotlin-dsl cd github-actions-kotlin-dsl If you have your workflow available in a local file, run: ./gradlew :script-generator:run --args /path/to/.github/workflows/build.yaml If your YAML workflow is available publicly, e.g. on GitHub, use such command referring to the raw file: ./gradlew :script-generator:run --args https://raw.githubusercontent.com/krzema12/github-actions-kotlin-dsl/0f41e3322a3e7de4199000fae54b398380eace2f/.github/workflows/build.yaml The script generator will communicate a successful generation and hint you what to do next: Kotlin script written to build.main.kts Run it with: ./build.main.kts The resulting YAML file with be available at build.yaml Compare the YAML files - semantically Running the script produced a file like build.yaml . It's recommended to verify if the generator produced a correct script. You cannot compare it directly with the original file because there are multiple ways to encode the same YAML content. For example, certain formatting differences are possible, the lists can be expressed either as separate lines starting with - or as values between [ and ] , and so on. Instead, a semantic YAML diff may be helpful, using e.g. https://yamldiff.com/ . It will show you what really changed: Use the Kotlin script Now you don't need your old YAML file. The new source of truth about your workflow's logic is the Kotlin script, and the generated YAML serves only as a preview what actually will be executed by GitHub. Please refer to Getting started chapter to learn how to use the new script and make it work on GitHub.","title":"Script generator"},{"location":"user-guide/script-generator/#generate-kotlin-script-from-existing-yaml","text":"To use it, clone the repository locally, in a version corresponding to the latest released version of the library: git clone -b v0.22.0 https://github.com/krzema12/github-actions-kotlin-dsl cd github-actions-kotlin-dsl If you have your workflow available in a local file, run: ./gradlew :script-generator:run --args /path/to/.github/workflows/build.yaml If your YAML workflow is available publicly, e.g. on GitHub, use such command referring to the raw file: ./gradlew :script-generator:run --args https://raw.githubusercontent.com/krzema12/github-actions-kotlin-dsl/0f41e3322a3e7de4199000fae54b398380eace2f/.github/workflows/build.yaml The script generator will communicate a successful generation and hint you what to do next: Kotlin script written to build.main.kts Run it with: ./build.main.kts The resulting YAML file with be available at build.yaml","title":"Generate Kotlin Script from existing YAML"},{"location":"user-guide/script-generator/#compare-the-yaml-files-semantically","text":"Running the script produced a file like build.yaml . It's recommended to verify if the generator produced a correct script. You cannot compare it directly with the original file because there are multiple ways to encode the same YAML content. For example, certain formatting differences are possible, the lists can be expressed either as separate lines starting with - or as values between [ and ] , and so on. Instead, a semantic YAML diff may be helpful, using e.g. https://yamldiff.com/ . It will show you what really changed:","title":"Compare the YAML files - semantically"},{"location":"user-guide/script-generator/#use-the-kotlin-script","text":"Now you don't need your old YAML file. The new source of truth about your workflow's logic is the Kotlin script, and the generated YAML serves only as a preview what actually will be executed by GitHub. Please refer to Getting started chapter to learn how to use the new script and make it work on GitHub.","title":"Use the Kotlin script"},{"location":"user-guide/type-safe-expressions/","text":"Typesafe GitHub Expressions GitHub expressions GitHub supports pretty advanced expressions via the ${{ ... }} syntax. They include: functions environment variables secrets different contexts like the runner or the github context events payloads and more (read here ). Here is an example run ( name = \"Environment variable and functions\" , command = \"echo \\ $ GITHUB_ACTORS \" , condition = \"\\ ${ { invariably ()} } \" , ) run ( name = \"GitHubContext echo sha\" , command = \"echo commit: \\ ${ { github . sha256 } } event: \\ ${ { github . event . release . zip_url } } \" ) Unfortunately, it is easy to get those expressions wrong. In fact this snippet contains four different errors . Can you spot them all? To make life easier, let us introduce type-safe GitHub expressions. The expr(\"\") helper function First, because \\${{ ... }} is awkward in Kotlin, it can be replaced by the expr(\"\") helper function - \"\\${{invariably()}}\" + expr(\"invariably()\") But this is still not type-safe. Type-safe functions with the expr { } DSL We went one step further towards type-safety by introducing the expr { } DSL. Goals: an invalid expression should not even compile. increase discoverability of what is available. For example, you can use auto-completion to find out which functions are available: Here we immediately see how to fix a first bug in our original snippet: - \"\\${{invariably()}}\" - expr(\"invariably()\") + expr { always() } Reference: https://docs.github.com/en/actions/learn-github-actions/expressions#functions The runner context The runner context contains information about the runner that is executing the current job. The possible properties are available via expr { runner.xxx } https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-runner-context The github context The github context contains information about the workflow run and the event that triggered the run. The possible properties are available via expr { github.xxx } Here we detect immediatly another bug in our original snippet -command = \"echo commit: ${'$'}{{ github.sha256 }} +command = \"echo commit: \" + expr { github.sha } Reference: https://docs.github.com/en/actions/learn-github-actions/contexts#github-context The github.eventXXX payload The github.event field is special because it depends on what kind of events triggered the workflow: Push PullRequest WorkflowDispatch Release ... Since they have a different type, there is a diferent property expr { github.eventXXX } per type: By leveraging this feature, we quickly fix another bug in our original snippet: Default environment variables GitHub supports a number of default environment variables. They are available directly in the IDE via the library's Contexts.env By using this feature in our snippet we would have avoided escaping the dollar and the typo: -command = \"echo \\$GITHUB_ACTORS\", +command = \"echo \" + Contexts.env.GITHUB_ACTOR, Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables Custom environment variables You are not limited to the default environment variables. You can create your own type-safe property by using the syntax val MY_VARIABLE_NAME by Contexts.env For example: val GREETING by Contexts . env val FIRST_NAME by Contexts . env job ( env = linkedMapOf ( GREETING to \"World\" , ) ) { run ( name = \"Custom environment variable\" , env = linkedMapOf ( FIRST_NAME to \"Patrick\" , ), command = \"echo $ GREETING $ FIRST_NAME \" ) } Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#about-environment-variables GitHub Secrets If you have sensitive information, you should store it as a GitHub secret: You use them the same way as environment variables, but using Contexts.secrets instead of Contexts.env : val SUPER_SECRET by Contexts.secrets For example: val SUPER_SECRET by Contexts . secrets val SECRET by Contexts . env val TOKEN by Contexts . env job ( id = \"job1\" , runsOn = RunnerType . UbuntuLatest ) { run ( name = \"Encrypted secret\" , env = linkedMapOf ( SECRET to expr { SUPER_SECRET }, TOKEN to expr { secrets . GITHUB_TOKEN } ), command = \"echo secret= $ SECRET token= $ TOKEN \" ) } Missing a feature? GitHub has more contexts that we don't support yet: https://docs.github.com/en/actions/learn-github-actions/contexts There are more github.event payloads that we currently do not support: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads We feel what we have is a pretty good start, but if you need an additional feature, you can create an issue Or maybe have a look how this type-safe feature is implemented in it.krzeminski.githubactions.dsl.expressions and submit a pull request \ud83d\ude4f\ud83c\udffb","title":"Type-safe expressions"},{"location":"user-guide/type-safe-expressions/#typesafe-github-expressions","text":"","title":"Typesafe GitHub Expressions"},{"location":"user-guide/type-safe-expressions/#github-expressions","text":"GitHub supports pretty advanced expressions via the ${{ ... }} syntax. They include: functions environment variables secrets different contexts like the runner or the github context events payloads and more (read here ). Here is an example run ( name = \"Environment variable and functions\" , command = \"echo \\ $ GITHUB_ACTORS \" , condition = \"\\ ${ { invariably ()} } \" , ) run ( name = \"GitHubContext echo sha\" , command = \"echo commit: \\ ${ { github . sha256 } } event: \\ ${ { github . event . release . zip_url } } \" ) Unfortunately, it is easy to get those expressions wrong. In fact this snippet contains four different errors . Can you spot them all? To make life easier, let us introduce type-safe GitHub expressions.","title":"GitHub expressions"},{"location":"user-guide/type-safe-expressions/#the-expr-helper-function","text":"First, because \\${{ ... }} is awkward in Kotlin, it can be replaced by the expr(\"\") helper function - \"\\${{invariably()}}\" + expr(\"invariably()\") But this is still not type-safe.","title":"The expr(\"\") helper function"},{"location":"user-guide/type-safe-expressions/#type-safe-functions-with-the-expr-dsl","text":"We went one step further towards type-safety by introducing the expr { } DSL. Goals: an invalid expression should not even compile. increase discoverability of what is available. For example, you can use auto-completion to find out which functions are available: Here we immediately see how to fix a first bug in our original snippet: - \"\\${{invariably()}}\" - expr(\"invariably()\") + expr { always() } Reference: https://docs.github.com/en/actions/learn-github-actions/expressions#functions","title":"Type-safe functions with the expr { }  DSL"},{"location":"user-guide/type-safe-expressions/#the-runner-context","text":"The runner context contains information about the runner that is executing the current job. The possible properties are available via expr { runner.xxx } https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-runner-context","title":"The runner context"},{"location":"user-guide/type-safe-expressions/#the-github-context","text":"The github context contains information about the workflow run and the event that triggered the run. The possible properties are available via expr { github.xxx } Here we detect immediatly another bug in our original snippet -command = \"echo commit: ${'$'}{{ github.sha256 }} +command = \"echo commit: \" + expr { github.sha } Reference: https://docs.github.com/en/actions/learn-github-actions/contexts#github-context","title":"The github context"},{"location":"user-guide/type-safe-expressions/#the-githubeventxxx-payload","text":"The github.event field is special because it depends on what kind of events triggered the workflow: Push PullRequest WorkflowDispatch Release ... Since they have a different type, there is a diferent property expr { github.eventXXX } per type: By leveraging this feature, we quickly fix another bug in our original snippet:","title":"The github.eventXXX payload"},{"location":"user-guide/type-safe-expressions/#default-environment-variables","text":"GitHub supports a number of default environment variables. They are available directly in the IDE via the library's Contexts.env By using this feature in our snippet we would have avoided escaping the dollar and the typo: -command = \"echo \\$GITHUB_ACTORS\", +command = \"echo \" + Contexts.env.GITHUB_ACTOR, Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables","title":"Default environment variables"},{"location":"user-guide/type-safe-expressions/#custom-environment-variables","text":"You are not limited to the default environment variables. You can create your own type-safe property by using the syntax val MY_VARIABLE_NAME by Contexts.env For example: val GREETING by Contexts . env val FIRST_NAME by Contexts . env job ( env = linkedMapOf ( GREETING to \"World\" , ) ) { run ( name = \"Custom environment variable\" , env = linkedMapOf ( FIRST_NAME to \"Patrick\" , ), command = \"echo $ GREETING $ FIRST_NAME \" ) } Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#about-environment-variables","title":"Custom environment variables"},{"location":"user-guide/type-safe-expressions/#github-secrets","text":"If you have sensitive information, you should store it as a GitHub secret: You use them the same way as environment variables, but using Contexts.secrets instead of Contexts.env : val SUPER_SECRET by Contexts.secrets For example: val SUPER_SECRET by Contexts . secrets val SECRET by Contexts . env val TOKEN by Contexts . env job ( id = \"job1\" , runsOn = RunnerType . UbuntuLatest ) { run ( name = \"Encrypted secret\" , env = linkedMapOf ( SECRET to expr { SUPER_SECRET }, TOKEN to expr { secrets . GITHUB_TOKEN } ), command = \"echo secret= $ SECRET token= $ TOKEN \" ) }","title":"GitHub Secrets"},{"location":"user-guide/type-safe-expressions/#missing-a-feature","text":"GitHub has more contexts that we don't support yet: https://docs.github.com/en/actions/learn-github-actions/contexts There are more github.event payloads that we currently do not support: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads We feel what we have is a pretty good start, but if you need an additional feature, you can create an issue Or maybe have a look how this type-safe feature is implemented in it.krzeminski.githubactions.dsl.expressions and submit a pull request \ud83d\ude4f\ud83c\udffb","title":"Missing a feature?"},{"location":"user-guide/using-actions/","text":"Using actions As a reminder, to be able to use an action, you have to know its owner, name and version, e.g. actions/checkout@v3 . The library comes bundled with some popular actions, but you can consume any action you want. Read on to learn about your possibilities. Built-in actions Take a look here: Supported actions . These are actions ready to use, grouped by owners. For actions/checkout@v3 , there's CheckoutV3 accepting all inputs defined in its metadata file, along with some basic typing. You may notice that for each major version, a separate class exists. It's because it's assumed Semantic Versioning is used to version the actions, as recommended by GitHub (in practice: there are exceptions). Each new major version means a breaking change, and it usually means that the Kotlin wrapper for the action needs a breaking change as well. User-defined actions If your action is not bundled with the library, you are in a hurry and contributing to the library now is not an option, you have two ways to proceed. Typed wrapper When to use this approach It lets you create an action wrapper in a similar manner that is provided by the built-in action wrappers in this library, i.e. a class that takes some constructor arguments with types of your choice, and maps them to strings inside toYamlArguments . Use it to have better type-safety when using the wrapper. Inherit from Action in case of actions without outputs: class MyCoolActionV3 ( private val someArgument : String , ) : Action ( \"acmecorp\" , \"cool-action\" , \"v3\" ) { override fun toYamlArguments () = linkedMapOf ( \"some-argument\" to someArgument , ) } or, in case actions with outputs, from ActionWithOutputs : class MyCoolActionV3 ( private val someArgument : String , ) : ActionWithOutputs < MyCoolActionV3 . Outputs > ( \"acmecorp\" , \"cool-action\" , \"v3\" ) { override fun toYamlArguments () = linkedMapOf ( \"some-argument\" to someArgument , ) override fun buildOutputObject ( stepId : String ) = Outputs ( stepId ) class Outputs ( private val stepId : String ) { public val coolOutput : String = \"steps. $ stepId .outputs.coolOutput\" public operator fun `get` ( outputName : String ) = \"steps. $ stepId .outputs. $ outputName \" } } Once you've got your action, it's now as simple as using it like this: uses ( name = \"FooBar\" , action = MyCoolActionV3 ( someArgument = \"foobar\" )) Untyped wrapper When to use this approach It omits typing entirely, and both inputs and outputs are referenced using strings. Use it if you don't care about types because you're in the middle of experimenting. It's also more convenient to produce such code by a code generator. Use a CustomAction : val customAction = CustomAction ( actionOwner = \"xu-cheng\" , actionName = \"latex-action\" , actionVersion = \"v2\" , inputs = linkedMapOf ( \"root_file\" to \"report.tex\" , \"compiler\" to \"latexmk\" , ) ) If your custom action has outputs, you can access them, albeit in a type-unsafe manner: job ( \"test_job\" , runsOn = RunnerType . UbuntuLatest ) { val customActionStep = uses ( name = \"Some step with output\" , action = customAction , ) // use your outputs: println ( expr ( customActionStep . outputs [ \"custom-output\" ] )) }","title":"Using actions"},{"location":"user-guide/using-actions/#using-actions","text":"As a reminder, to be able to use an action, you have to know its owner, name and version, e.g. actions/checkout@v3 . The library comes bundled with some popular actions, but you can consume any action you want. Read on to learn about your possibilities.","title":"Using actions"},{"location":"user-guide/using-actions/#built-in-actions","text":"Take a look here: Supported actions . These are actions ready to use, grouped by owners. For actions/checkout@v3 , there's CheckoutV3 accepting all inputs defined in its metadata file, along with some basic typing. You may notice that for each major version, a separate class exists. It's because it's assumed Semantic Versioning is used to version the actions, as recommended by GitHub (in practice: there are exceptions). Each new major version means a breaking change, and it usually means that the Kotlin wrapper for the action needs a breaking change as well.","title":"Built-in actions"},{"location":"user-guide/using-actions/#user-defined-actions","text":"If your action is not bundled with the library, you are in a hurry and contributing to the library now is not an option, you have two ways to proceed.","title":"User-defined actions"},{"location":"user-guide/using-actions/#typed-wrapper","text":"When to use this approach It lets you create an action wrapper in a similar manner that is provided by the built-in action wrappers in this library, i.e. a class that takes some constructor arguments with types of your choice, and maps them to strings inside toYamlArguments . Use it to have better type-safety when using the wrapper. Inherit from Action in case of actions without outputs: class MyCoolActionV3 ( private val someArgument : String , ) : Action ( \"acmecorp\" , \"cool-action\" , \"v3\" ) { override fun toYamlArguments () = linkedMapOf ( \"some-argument\" to someArgument , ) } or, in case actions with outputs, from ActionWithOutputs : class MyCoolActionV3 ( private val someArgument : String , ) : ActionWithOutputs < MyCoolActionV3 . Outputs > ( \"acmecorp\" , \"cool-action\" , \"v3\" ) { override fun toYamlArguments () = linkedMapOf ( \"some-argument\" to someArgument , ) override fun buildOutputObject ( stepId : String ) = Outputs ( stepId ) class Outputs ( private val stepId : String ) { public val coolOutput : String = \"steps. $ stepId .outputs.coolOutput\" public operator fun `get` ( outputName : String ) = \"steps. $ stepId .outputs. $ outputName \" } } Once you've got your action, it's now as simple as using it like this: uses ( name = \"FooBar\" , action = MyCoolActionV3 ( someArgument = \"foobar\" ))","title":"Typed wrapper"},{"location":"user-guide/using-actions/#untyped-wrapper","text":"When to use this approach It omits typing entirely, and both inputs and outputs are referenced using strings. Use it if you don't care about types because you're in the middle of experimenting. It's also more convenient to produce such code by a code generator. Use a CustomAction : val customAction = CustomAction ( actionOwner = \"xu-cheng\" , actionName = \"latex-action\" , actionVersion = \"v2\" , inputs = linkedMapOf ( \"root_file\" to \"report.tex\" , \"compiler\" to \"latexmk\" , ) ) If your custom action has outputs, you can access them, albeit in a type-unsafe manner: job ( \"test_job\" , runsOn = RunnerType . UbuntuLatest ) { val customActionStep = uses ( name = \"Some step with output\" , action = customAction , ) // use your outputs: println ( expr ( customActionStep . outputs [ \"custom-output\" ] )) }","title":"Untyped wrapper"}]}